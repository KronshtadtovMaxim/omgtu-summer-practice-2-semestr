#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!csharp

using System.Collections.Concurrent;
using System.Threading;
using System.Diagnostics;
Stopwatch sw = new();
Stopwatch sw1 = new();
Stopwatch sw2 = new();
List<double> y = new();
for(int i = 0; i<10; i++){
ConcurrentQueue<int> q = new ConcurrentQueue<int>();
Barrier br = new(2);
int asd = 1000000;
ManualResetEvent re = new(false);
Thread thread = new Thread(() =>
{
    re.WaitOne();
    sw2.Start();
    sw.Start();
    for(int i = 0; i<1000000; i++)
    {
        q.Enqueue(i);
    }
    sw.Stop();
    br.SignalAndWait();
});
int qqq;
Thread thread1 = new Thread(() =>
{
    re.WaitOne();
    sw1.Start();
        while(asd > 0)
        {
            if(q.TryDequeue(out qqq))
            {
                Interlocked.Decrement(ref asd);
            }
        }
    sw1.Stop();
    sw2.Stop();
    br.SignalAndWait();
});
thread.Start();
thread1.Start();
re.Set();
thread.Join();
}
y.Add(sw.Elapsed.TotalMilliseconds/10);
y.Add(sw1.Elapsed.TotalMilliseconds/10);
y.Add(sw2.Elapsed.TotalMilliseconds/10);
Console.WriteLine($"Среднее время записи миллиона объектов в ConcurrentQueue: {sw.Elapsed.TotalMilliseconds/10}");
Console.WriteLine($"Среднее время чтения миллиона объектов из ConcurrentQueue: {sw1.Elapsed.TotalMilliseconds/10}");
Console.WriteLine($"Среднее время обработки миллиона объектов из ConcurrentQueue: {sw2.Elapsed.TotalMilliseconds/10}");

#!csharp

sw.Reset();
sw1.Reset();
sw2.Reset();
for(int i = 0; i<10; i++){
BlockingCollection<int> q = new BlockingCollection<int>();
Barrier br = new(2);
ManualResetEvent re = new(false);
Thread thread = new Thread(() =>
{
    re.WaitOne();
    sw2.Start();
    sw.Start();
    for(int i = 0; i<1000000; i++)
    {
        q.Add(i);
    }
    sw.Stop();
    br.SignalAndWait();
});
Thread thread1 = new Thread(() =>
{
    re.WaitOne();
    sw1.Start();
    for(int i = 0; i<1000000; i++)
    {
        q.Take();
    }
    sw1.Stop();
    sw2.Stop();
    br.SignalAndWait();
});
thread.Start();
thread1.Start();
re.Set();
thread.Join();
}
y.Add(sw.Elapsed.TotalMilliseconds/10);
y.Add(sw1.Elapsed.TotalMilliseconds/10);
y.Add(sw2.Elapsed.TotalMilliseconds/10);
Console.WriteLine($"Среднее время записи миллиона объектов в BlockingCollection: {sw.Elapsed.TotalMilliseconds/10}");
Console.WriteLine($"Среднее время чтения миллиона объектов из BlockingCollection: {sw1.Elapsed.TotalMilliseconds/10}");
Console.WriteLine($"Среднее время обработки миллиона объектов из BlockingCollection: {sw2.Elapsed.TotalMilliseconds/10}");

#!csharp

sw.Reset();
sw1.Reset();
sw2.Reset();
for(int i = 0; i<10; i++){
Queue<int> q = new Queue<int>();
    sw2.Start();
    sw.Start();
    for(int ii = 0; ii<1000000; ii++)
    {
        q.Append(ii);
    }
    sw.Stop();
    sw1.Start();
    for(int j = 0; j<1000000; j++)
    {
        q.Take(j);
    }
    sw1.Stop();
    sw2.Stop();

}
y.Add(sw.Elapsed.TotalMilliseconds/10);
y.Add(sw1.Elapsed.TotalMilliseconds/10);
y.Add(sw2.Elapsed.TotalMilliseconds/10);
Console.WriteLine($"Среднее время записи миллиона объектов в Queue: {sw.Elapsed.TotalMilliseconds/10}");
Console.WriteLine($"Среднее время чтения миллиона объектов из Queue: {sw1.Elapsed.TotalMilliseconds/10}");
Console.WriteLine($"Среднее время обработки миллиона объектов из Queue: {sw2.Elapsed.TotalMilliseconds/10}");
List<int> x = new(){1,2,3,4,5,6,7,8,9};

#!csharp

#r "nuget:ScottPlot, 5.0.35"
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
    ScottPlot.Plot plt = new();
    plt.Add.Scatter(y,x);
    plt

#!markdown

1-3 - ConcurrentQueue, 4-6 - BlockingCollection, 7-9 - Queue. Значения в миллисекундах.

#!markdown

## Вывод


Из потокобезопасных коллекций наиболее эффективна ConcurrentQueue, что можно заметить по графику. Соотношению скорости обычной очереди и ConcurrentQueue равняется примерно 66 процентам.
